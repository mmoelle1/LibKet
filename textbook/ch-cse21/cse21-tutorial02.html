<!DOCTYPE html>



<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Part 2</title>
  <meta name="description" content="A cross-platform programming framework for quantum-accelerated scientific computing">

  <link rel="canonical" href="https://libket.ewi.tudelft.nl/textbook/ch-cse21/cse21-tutorial02.html">
  <link rel="alternate" type="application/rss+xml" title="LibKet Learn" href="https://libket.ewi.tudelft.nl/textbook/feed.xml">

  

  <link rel="alternate" hreflang="en" href="https://libket.ewi.tudelft.nl/textbook/ch-cse21/cse21-tutorial02.html" />
  <link rel="alternate" hreflang="ja" href="https://libket.ewi.tudelft.nl/textbook/ja/ch-cse21/cse21-tutorial02.html" />
  <link rel="alternate" hreflang="x-default" href="https://libket.ewi.tudelft.nl/textbook/ch-cse21/cse21-tutorial02.html" />

  <meta property="og:url"         content="https://libket.ewi.tudelft.nl/textbook/ch-cse21/cse21-tutorial02.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Part 2" />
<meta property="og:description" content="A cross-platform programming framework for quantum-accelerated scientific computing" />
<meta property="og:image"       content="https://libket.ewi.tudelft.nl/textbook/images/preface_illustration.svg" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://libket.ewi.tudelft.nl/textbook/ch-cse21/cse21-tutorial02.html",
  "headline": "Part 2",
  "datePublished": "2021-10-18T15:45:15+00:00",
  "dateModified": "2021-10-18T15:45:15+00:00",
  "description": "        Part 2    LibKet - The Quantum Expression Template Library.Repository:    https://gitlab.com/mmoelle1/LibKet/Documentation: https://libket.readthedoc...",
  "author": {
    "@type": "Person",
    "name": "The LibKet Team"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://libket.ewi.tudelft.nl/textbook",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://libket.ewi.tudelft.nl/textbook",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link id="theme-style" rel="stylesheet" href="/textbook/assets/css/styles.css">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/textbook/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    },
    
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML-full,Safe' async></script>


  <!-- DOM updating function -->
  <script src="/textbook/assets/js/page/dom-update.js"></script>

  <!-- Selectors for elements on the page -->
  <script src="/textbook/assets/js/page/documentSelectors.js"></script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/textbook';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script src="/textbook/assets/js/page/anchors.js" async></script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <!-- Turbolinks were causing problems with equations in details tags, I have
	  removed them for now as I didn't notice a siginificant difference in
	  loading time, but maybe someone more knowledgeable than me can sort
	  the problem properly and re-enable -Frank
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">
  -->

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->


<!-- Display Thebelab button in each code cell -->
<script>
/**
 * Set up thebelab button for code blocks
 */

const thebelabCellButton = id =>
  `<a id="thebelab-cell-button-${id}" class="btn thebebtn">
    <button>try</button>
  </a>`


const addThebelabButtonToCodeCells =  () => {

  const codeCells = document.querySelectorAll('div.input_area > div.highlight:not(.output) pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.getElementById("thebelab-cell-button-" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', thebelabCellButton(id));
    }
  })
}

initFunction(addThebelabButtonToCodeCells);
</script>



<script>
    /**
     * Thebelab loads "reset CSS" after the theme styles load and so,
     * it invalidates part of the theme rules. To make the theme CSS to take
     * the correct precedence, we listen for Thebelab to finish loading, then
     * relocate the theme CSS and start Thebelab.
     */
    const thebeLabScript = document.createElement('script');
    thebeLabScript.src = "/textbook/assets/vendor/thebelab/index.js"
    thebeLabScript.async = true
    thebeLabScript.onload = () => {
        setTimeout(() => {
            document.head.append(
                ...document.querySelectorAll('#theme-style, #custom-style'))
        })
        initFunction(initThebelab)
    }
    document.head.append(thebeLabScript);

    /**
     * Add attributes to Thebelab blocks
     */
    function initThebelab() {
        const addThebelabToCodeCells = () => {
            console.log("Adding thebelab to code cells...");
            // If Thebelab hasn't loaded, wait a bit and try again. This
            // happens because we load ClipboardJS asynchronously.
            if (window.thebelab === undefined) {
                setTimeout(addThebelabToCodeCells, 250)
            return
            }

            // If we already detect a Thebelab cell, don't re-run
            if (document.querySelectorAll('div.thebelab-cell').length > 0) {
                return;
            }

            // Find all non-hardware, code cells, replace with Thebelab interactive code cells
            const hardwareTag = 'uses-hardware'
            const hardwareQuery = `.jb_cell.tag_${hardwareTag}`
            const noHardwareQuery = `.jb_cell:not(.tag_${hardwareTag})`
            const codeCells = document.querySelectorAll(`${noHardwareQuery} pre[id^="codecell"]`)
            codeCells.forEach((codeCell, index) => {
                const id = codeCellId(index)

                // Clean up the language to make it work w/ CodeMirror and add it to the cell
                dataLanguage = ""
                dataLanguage = detectLanguage(dataLanguage);
                codeCell.setAttribute('data-language', dataLanguage)
                codeCell.setAttribute('data-executable', 'true')

                // If the code cell is hidden, show it
                var inputCheckbox = document.querySelector(`input#hidebtn${codeCell.id}`);
                if (inputCheckbox !== null) {
                    setCodeCellVisibility(inputCheckbox, 'visible');
                }
            });

            // Create link to IQX and hardware notice template
            const currentPath = window.location.pathname
            const contentPath = currentPath.slice('/textbook'.length)
            const notebookPath = contentPath.replace(/\.html$/, '.ipynb')
            const iqxUrl = `https://quantum-computing.ibm.com/jupyter/user/qiskit-textbook/content${notebookPath}`

            const usesHardwareNotice = document.createElement('template')
            usesHardwareNotice.innerHTML = `
            <div class="uses-hardware-notice">
                This cell uses quantum hardware. To run it in your browser, please 
                <a href="${iqxUrl}" target="_blank">click here to go to the IBM Quantum Experience.</a>
            </div>
            `

            // Add warning and link to IQX on uses-hardware cells
            const hardwareCells = document.querySelectorAll(hardwareQuery)
            hardwareCells.forEach((cell) => {
                cell.prepend(usesHardwareNotice.content.cloneNode(true))
                cell.querySelector('a').addEventListener('click', (evt) => {
                    try {
                        window.trackCta(`Hardware Cell ${getInputCell(evt.target)}`)
                    } catch {}
                    return true;
                })
            });

            // Remove the event listener from the page so keyboard press doesn't
            // Change page
            document.removeEventListener('keydown', initPageNav)
            keyboardListener = false;

            // Init thebelab
            thebelab.bootstrap();

            // Remove copy buttons since they won't work anymore
            const copyAndThebeButtons = document.querySelectorAll(`${noHardwareQuery} .copybtn, .thebebtn`)
            copyAndThebeButtons.forEach((button, index) => {
                button.remove();
            });

            // Remove outputs since they'll be stale (ignore outputs with removed inputs)
            const outputs = document.querySelectorAll(':not(.tag_remove_input) > .output_wrapper')
            outputs.forEach((output, index) => {
                output.remove();
            });

            // Find any cells with an initialization tag and ask ThebeLab to run them when ready
            var thebeInitCells = document.querySelectorAll('div.tag_thebelab-init');
            thebeInitCells.forEach((cell) => {
                console.log("Initializing ThebeLab with cell: " + cell.id);
                cell.querySelector('.thebelab-run-button').click();
            });

            // Add analytics per cell
            const thebelabRunButtons = document.querySelectorAll('.thebelab-run-button');
            thebelabRunButtons.forEach((runButton) => {
                runButton.addEventListener('click', (evt) => {
                    window.trackCta(`Run ${getInputCell(evt.target)}`)
                })
            });
        }

        // Add event listener for the function to modify code cells
        const thebelabButtons = document.querySelectorAll('[id^=thebelab], [id$=thebelab]')
        thebelabButtons.forEach((thebelabButton,index) => {
            if (thebelabButton === null) {
                setTimeout(initThebelab, 250)
                return
            };
            thebelabButton.addEventListener('click', addThebelabToCodeCells);
            // Add segment analytics
            thebelabButton.addEventListener('click', () => {
                window.trackCta('Make Interactive');
            });
        });

        function getInputCell(button) {
            const parent = button.parentElement;
            if (parent === null) {
                return 'unknown';
            }
            if (parent.id.startsWith('inputcell')) {
                return parent.id;
            }
            return getInputCell(parent);
        }
        addThebelabToCodeCells();
    }

// Helper function to munge the language name
var detectLanguage = (language) => {
    if (language.indexOf('python') > -1) {
        language = "python";
    }
    return language;
}
</script>



  <!-- Load the auto-generating TOC (non-async otherwise the TOC won't load w/ turbolinks) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.8.1/tocbot.min.js" async></script>
  <script src="/textbook/assets/js/page/tocbot.js"></script>

  <!-- Google analytics -->
  


  <!-- Segment analytics -->
  <script>
(function () {
  'use strict'
  window._analytics = {
    segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw',
    coremetrics: false,
    optimizely: false,
    googleAddServices: false,
    fullStory: false,
    autoPageEventSpa: false,
    autoFormEvents: false,
    autoPageView: false
  }

  window.digitalData = {
    page: {
      pageInfo: {
        productTitle: 'IBM Q Experience',
        analytics: {
          category: 'Qiskit.org'
        }
      }
    }
  }

  loadAsyncScript('https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js')
  .then(() => {
    if (!window.bluemixAnalytics || !window.digitalData) { return }

    const category = window.digitalData.page.pageInfo.analytics.category
    const productTitle = window.digitalData.page.pageInfo.productTitle
    const routeName = 'qiskit-textbook'

    window.bluemixAnalytics.pageEvent(category, routeName, {
      navigationType: 'pushState',
      productTitle: productTitle,
      title: document.title
    })
  })
  .catch((err) => {
    console.warn('Error loading Bluemix Analytics script:', err)
  })

  window.trackCta = (action) => {
    if (!window.bluemixAnalytics || !window.digitalData) { return }

    const category = window.digitalData.page.pageInfo.analytics.category
    const productTitle = window.digitalData.page.pageInfo.productTitle

    window.bluemixAnalytics.trackEvent('CTA Clicked', {
      productTitle,
      category,
      CTA: action
    })
  }

}());
</script>

  <!-- Hotjar -->
  <!-- <script>
  (function(h,o,t,j,a,r){
    h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
    h._hjSettings={hjid:1586421,hjsv:6};
    a=o.getElementsByTagName('head')[0];
    r=o.createElement('script');r.async=1;
    r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
    a.appendChild(r);
  })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
 -->

  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/textbook/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/textbook/assets/custom/custom.js" async></script>
  <link id="custom-style" rel="stylesheet" href="/textbook/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  
<script>
/**
  * To auto-embed hub URLs in interact links if given in a RESTful fashion
 */

function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
    
function dict2param(dict) {
    params = Object.keys(dict).map(function(k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(dict[k])
    });
    return params.join('&')
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return dict2param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = document.querySelectorAll("a").forEach(function(link) {
    var href = link.href;
    // If the link is an internal link...
    if (href.search("https://libket.ewi.tudelft.nl") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['jupyterhub'] = hub;
      } else {
        // Create the REST params
        params = {'jupyterhub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + dict2param(params);
      link.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}


// Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    jupyterHubUrl = rest['jupyterhub'];
    var hubType = null;
    var hubUrl = null;
    if (jupyterHubUrl !== undefined) {
      hubType = 'jupyterhub';
      hubUrl = jupyterHubUrl;
    }

    if (hubType !== null) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);

      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      var interactButtons = document.querySelectorAll("button.interact-button")
      var lastButton = interactButtons[interactButtons.length-1];
      var link = lastButton.parentElement;

      // If we've already run this, skip the link updating
      if (link.nextElementSibling !== null) {
        return;
      }

      // Update the link and add context div
      var href = link.getAttribute('href');
      if (lastButton.id === 'interact-button-binder') {
        // If binder links exist, we need to re-work them for jupyterhub
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // If localhost, assume we're working from a local Jupyter server and remove `/hub`
          first = [hubUrl, 'git-sync'].join('/')
        } else {
          first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
        }
        href = first + '?' + binder2Jupyterhub(href);
      } else {
        // If interact button isn't binderhub, assume it's jupyterhub
        // If JupyterHub links, we only need to replace the hub url
        href = href.replace("", hubUrl);
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // Assume we're working from a local Jupyter server and remove `/hub`
          href = href.replace("/hub/user-redirect", "");
        }
      }
      link.setAttribute('href', decodeURIComponent(href));

      // Add text after interact link saying where we're launching
      hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
      link.insertAdjacentHTML('afterend', '<div class="interact-context">on ' + hubUrlNoHttp + '</div>');

      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

runWhenDOMLoaded(updateInteractLink)
document.addEventListener('turbolinks:load', updateInteractLink)
</script>


  <!-- Lunr search code - will only be executed on the /search page -->
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

// Fills in the search input with the query in the url
var prepopulateSearchInput = function () {
  var searchInput = document.getElementById('lunr_search');
  if (!searchInput) { return }

  var params = new URLSearchParams(window.location.search)
  var searchValue = params.get('search')
  if (!searchValue) { return }
  searchInput.value = searchValue.trim()
}

// Simulate a 'keyup' event to trigger a search
var triggerSearch = function () {
  var searchInput = document.getElementById('lunr_search');
  if (!searchInput || !searchInput.value.trim()) { return }

  searchInput.focus();
  var enterEvent = document.createEvent('Event');
  enterEvent.initEvent('keyup');
  searchInput.dispatchEvent(enterEvent);
}

initFunction(prepopulateSearchInput)

loadAsyncScript('https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js')
.then(() => {
  initFunction(initQuery)
  initFunction(triggerSearch)
})
.catch((err) => console.error('Cannot load lunr search engine:', err))
</script>

  <!-- Load JS that depends on site variables -->
  <script src="/textbook/assets/js/page/copy-button.js" async></script>

  <!-- Hide cell code -->
  <script src="/textbook/assets/js/page/hide-cell.js" async></script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/textbook/assets/css/styles.css",
        style: "#textbook_content {padding-top: 40px};",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList,
        documentTitle: "Made with Jupyter Book"
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- Include the ThebeLab config so it gets reloaded on each page -->
    <script type="text/x-thebe-config">{
    requestKernel: true,
    binderOptions: {
    repo: "mmoelle1/LibKet",
    ref: "master",
    },
    codeMirrorConfig: {
    theme: "abcdef",
    mode: ""
    },
    kernelOptions: {
    kernelName: "xcpp14",
    path: "content/ch-cse21"
    }
}
</script>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
    <div id="libket-navbar" class="libket__navbar">
    


<ul class="libket-navbar">
    <li class="left navbar__logo">
	    <a href="https://libket.ewi.tudelft.nl/">
	    <img src="/textbook/assets/images/logo_libket_white.png">
	    </a>
    </li>
    <li class="libket-navbar__icons"><a href="/textbook/search.html"><img src="/textbook/assets/images/search-solid-purple.svg"></a></li>
    <li class="entry__active"><a href="https://libket.readthedocs.io/">Documentation</a></li>
 </ul>


    </div>

      






<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="/textbook/preface.html"><h2 class="c-sidebar__title">LibKet Learn</h2></a>
  <ul class="c-sidebar__chapters">
    
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/preface">
        <a class="c-sidebar__entry"
          href="/textbook/preface.html"
        >
          
          LibKet Learn
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/ch-cse21/index">
        <a class="c-sidebar__entry"
          href="/textbook/ch-cse21/index"
        >
          
            1.
          
          SIAM CSE1 Tutorial
        </a>
      </li>

      
      

      

      
      

      
        

        

        <ul class="c-sidebar__sections">
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/ch-cse21/cse21-tutorial01">
              <a class="c-sidebar__entry"
                href="/textbook/ch-cse21/cse21-tutorial01.html"
              >
                
                  1.1
                
                Part 1
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/ch-cse21/cse21-tutorial02">
              <a class="c-sidebar__entry"
                href="/textbook/ch-cse21/cse21-tutorial02.html"
              >
                
                  1.2
                
                Part 2
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/ch-cse21/cse21-tutorial03">
              <a class="c-sidebar__entry"
                href="/textbook/ch-cse21/cse21-tutorial03.html"
              >
                
                  1.3
                
                Part 3
              </a>
            </li>
            
            
          
        </ul>
      

      
    
  </ul>
  <div class="sidebar_footer">
    <!-- Powered by <a href="https://github.com/jupyter/jupyter-book">Jupyter Book</a> -->
    
    <div class="language_switcher">
      <select name="preferred_language" onchange="changeLocale('', this.value)">
        <option value="en" >English</option>
      </select>
    </div>

  </div>
</nav>

      
      

<div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="hamburger__left">
    <span id="js-sidebar-toggle" class="hamburger is-active">
	    <img class="sidebar_closed_img" src="/textbook/assets/images/rightarrow_purple.svg" title="Show Contents">
	    <img class="sidebar_open_img" src="/textbook/assets/images/leftarrow_purple.svg" title="Hide Contents">
    </span>
  </aside>
  
  <aside class="sidebar__right">
  
    <!-- Search form -->
    <header>
      <form action="/textbook/search.html" method="GET">
        <button type="submit" id="submit">
          <img src="/textbook/assets/images/search-solid.svg" alt="Search">
        </button>
        <input type="text" id="siderbar-search-input" name="search">
      </form>
    </header>

    
    <div class="onthispage__title">On This Page</div>
    <nav class="onthispage">
    </nav>
    <!-- Chapter formats -->
    
    <div>
      <a
        href="/textbook/content/ch-cse21/cse21-tutorial02.ipynb"
        rel="noopener"
        class="download__link"
      >
        Download as Jupyter Notebook
        <img src="/textbook/assets/images/download-solid.svg" class="download-button">
      </a>
    </div>
   <div>
      <a
	href="https://github.com/mmoelle1/LibKet/tree/master/content/ch-cse21/cse21-tutorial02.ipynb"
	class="download__link"
      >
      Contribute on Github
      <img src="/textbook/assets/images/launch.svg" class="download-button">
      </a>
    </div>
    
  
  </aside>
  <!--
  <a href="/textbook/search.html" class="topbar-right-button" id="search-button">
    <img src="/textbook/assets/images/search-solid.svg" alt="Search" />
  </a>
  -->
</div>

      <main class="c-textbook__page" tabindex="-1">
            <div class="c-textbook__content" id="textbook_content">
                  <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Part 2</div>
</div>
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="https://gitlab.com/mmoelle1/LibKet"><img src="../images/LibKet.png" alt="LibKet"></a>
<strong>LibKet - The Quantum Expression Template Library.</strong></p>
<ul>
<li>Repository:    <a href="https://gitlab.com/mmoelle1/LibKet/">https://gitlab.com/mmoelle1/LibKet/</a></li>
<li>Documentation: <a href="https://libket.readthedocs.io/">https://libket.readthedocs.io/</a></li>
<li>API docs:      <a href="https://mmoelle1.gitlab.io/LibKet/">https://mmoelle1.gitlab.io/LibKet/</a></li>
</ul>
<hr>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Tutorial-#2:-Hands-on-Scientific-Computing-with-LibKet---Part-1">Tutorial #2: Hands-on Scientific Computing with LibKet - Part 1<a class="anchor-link" href="#Tutorial-#2:-Hands-on-Scientific-Computing-with-LibKet---Part-1"> </a></h1><p>In this tutorial you will learn to</p>
<ol>
<li>offload quantum expressions to different quantum devices</li>
<li>customize the offloading pipeline</li>
<li>visualize results using Qiskit</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Getting-started">Getting started<a class="anchor-link" href="#Getting-started"> </a></h2><p>Let's include <strong>LibKet</strong>'s main headerfile and import its namespaces. This can take some time, stay tuned.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;LibKet.hpp&quot;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">LibKet</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">LibKet</span><span class="o">::</span><span class="nn">circuits</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">LibKet</span><span class="o">::</span><span class="nn">filters</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">LibKet</span><span class="o">::</span><span class="nn">gates</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let us create a simple quantum expression for the first Bell state</p>
<p><img src="../images/multi_qubit_circuit_HI_CNOT.png" alt="Bell state"></p>
<p>and evaluate it on different quantum backends. Don't forget to <code>measure</code> at the end since some backends do not support direct statevector readouts.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">measure</span><span class="p">(</span><span class="n">cnot</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">sel</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()),</span><span class="w"> </span><span class="n">sel</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init</span><span class="p">())));</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Cirq">Cirq<a class="anchor-link" href="#Cirq"> </a></h2><p><img src="../images/cirq_logo.png" alt="Cirq"></p>
<p><a href="https://quantumai.google/cirq">Cirq</a> is a Python package for writing, manipulating, and optimizing quantum circuits developed by Google. It is seamlessly integrated into <strong>LibKet</strong> using the embedded Python interpreter, so you should not notice all the technical details going on under the hood.</p>
<p>As for the <a href="https://quest.qtechtheory.org">QuEST</a> simulator, we simply create a quantum device for two qubits, load the quantum expression into it, and evaluate it.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">QDevice</span><span class="o">&lt;</span><span class="n">QDeviceType</span><span class="o">::</span><span class="n">cirq_simulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">;</span><span class="w"></span>
<span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cirq</span><span class="p">(</span><span class="n">expr</span><span class="p">).</span><span class="n">eval</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Unlike QuEST, Cirq returns the outcome of the evaluation as JSON object which we can print directly</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also get a slightly prettier output</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As this is still not too informative, <strong>LibKet</strong> provides quick access <code>get&lt;...&gt;()</code> functions to retrieve information about the <code>duration</code> of the quantum computation, a <code>histogram</code> of all measured states, and the <code>best</code> state, i.e. the one that was measured most often</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;duration  : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">duration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; seconds&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;histogram : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">histogram</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;best      : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">best</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's increase the number of <strong>shots</strong>, i.e. the number of times we run the quantum circuit in our simulator, to <code>20</code> to see how the histogram changes</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;duration  : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">duration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; seconds&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;histogram : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">histogram</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;best      : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">best</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Qiskit">Qiskit<a class="anchor-link" href="#Qiskit"> </a></h2><p><img src="../images/qiskit_logo.png" alt="Qiskit"></p>
<p>Let's move on to the next quantum backend supported by <strong>LibKet</strong> - <a href="https://qiskit.org">Qiskit</a>. Without any changes to the quantum expression <code>expr</code>, we create a new Qiskit device, populate it with the quantum expression and run it the same way as before</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">QDevice</span><span class="o">&lt;</span><span class="n">QDeviceType</span><span class="o">::</span><span class="n">qiskit_qasm_simulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">qiskit</span><span class="p">;</span><span class="w"></span>
<span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qiskit</span><span class="p">(</span><span class="n">expr</span><span class="p">).</span><span class="n">eval</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;duration  : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">duration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; seconds&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;histogram : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">histogram</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;best      : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">best</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Rigetti">Rigetti<a class="anchor-link" href="#Rigetti"> </a></h2><p><img src="../images/rigetti_logo.png" alt="Rigetti"></p>
<p>Our third backend, <a href="https://www.rigetti.com">Rigetti</a>, requires some additional configuration as it relies on a quantum virtual machine (<a href="https://github.com/rigetti/qvm">qvm</a>) and a quantum compiler toolchain (<a href="https://github.com/rigetti/quilc">quilc</a>). Both tools can be <a href="https://pyquil-docs.rigetti.com/en/stable/start.html">installed</a> locally or on remote servers. You will be given the up-to-date IP addresses of our servers that run pre-built <a href="https://hub.docker.com/u/rigetti">docker images</a> during the tutorial session.</p>
<p>The easiest way to customize quantum devices is by means of the JSON-based constructor</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;qvm_url&quot;</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;http://68.183.13.151:80&quot;</span><span class="w">  </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;quilc_url&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tcp://104.248.201.181:80&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">QDevice</span><span class="o">&lt;</span><span class="n">QDeviceType</span><span class="o">::</span><span class="n">rigetti_9q_square_simulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rigetti</span><span class="p">(</span><span class="n">config</span><span class="p">);</span><span class="w"></span>
<span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rigetti</span><span class="p">(</span><span class="n">expr</span><span class="p">).</span><span class="n">eval</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;duration  : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rigetti</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">duration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; seconds&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;histogram : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rigetti</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">histogram</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;best      : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rigetti</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">QResultType</span><span class="o">::</span><span class="n">best</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's take a short look under the hood to see how much work is required to write low-level quantum assembly language (QASM) for the three simulators</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;---- Cirq ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Qiskit ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">qiskit</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-- Rigetti ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rigetti</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>LibKet</strong> is designed as backend-agnostic quantum programming framework with a unified API, which means that the core functionality is implemented for all quantum backends. If a particular backend does not support a specific function, e.g., Cirq does not report the <code>duration</code> of the quantum computation, default values are returned.</p>
<p>Some quantum backends provide extra functionality, which is exposed via <strong>LibKet</strong>. Cirq for instance can export the quantum circuit to <a href="https://www.latex-project.org">LaTeX</a> code using the <a href="https://ctan.org/pkg/qcircuit">Qcircuit</a> package</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cirq</span><span class="p">.</span><span class="n">to_latex</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">to_latex</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The resulting circuit looks as follows</p>
<p><img src="../images/qiskit_to_latex.png" alt="Bell state"></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Computation-offloading">Computation offloading<a class="anchor-link" href="#Computation-offloading"> </a></h2><p><strong>LibKet</strong>'s computation offloading model is very similar to that of <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a> to ease the transition from GPU- to quantum-accelerated computing. The <code>device.eval(...)</code> is just one of three ways to run a quantum expression, which we will refer to as <strong>quantum kernel</strong>, on a quantum device.</p>
<h4 id="LibKet::utils::json-device.eval(...)"><code>LibKet::utils::json device.eval(...)</code><a class="anchor-link" href="#LibKet::utils::json-device.eval(...)"> </a></h4><p>offloads the quantum computation to the quantum device and returns the evaluated result as JSON object once the quantum computation has completed. Exceptions are the QuEST and QX simulators where a reference to the internal state vector is returned.</p>
<h4 id="LibKet::QJob*-device.execute(...)"><code>LibKet::QJob* device.execute(...)</code><a class="anchor-link" href="#LibKet::QJob*-device.execute(...)"> </a></h4><p>offloads the quantum computation to the quantum device and returns a <code>QJob</code> pointer once the quantum computation has completed.</p>
<h4 id="LibKet::QJob*-device.execute_async(...)"><code>LibKet::QJob* device.execute_async(...)</code><a class="anchor-link" href="#LibKet::QJob*-device.execute_async(...)"> </a></h4><p>offloads the quantum computation to the quantum device and returns a <code>QJob</code> pointer immediately.</p>
<p>All three methods have the same interface. For Python-based quantum backends this is</p>
<div class="highlight"><pre><span></span><span class="n">QJob</span><span class="o">&lt;</span><span class="n">QJobType</span><span class="o">::</span><span class="n">Python</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">execute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">shots</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">ctor</span><span class="p">],</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">script_init</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">script_before</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">script_after</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">QStream</span><span class="o">&lt;</span><span class="n">QJobType</span><span class="o">::</span><span class="n">Python</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>and for backends implemented in C/C++ like QuEST and QX this is</p>
<div class="highlight"><pre><span></span><span class="n">QJob</span><span class="o">&lt;</span><span class="n">QJobType</span><span class="o">::</span><span class="n">CXX</span><span class="o">&gt;*</span><span class="w">    </span><span class="n">execute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w">                         </span><span class="n">shots</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">ctor</span><span class="p">],</span><span class="w"></span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">QDevice_QuEST</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ftor_init</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">QDevice_QuEST</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ftor_before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">QDevice_QuEST</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ftor_after</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">QStream</span><span class="o">&lt;</span><span class="n">QJobType</span><span class="o">::</span><span class="n">CXX</span><span class="o">&gt;*</span><span class="w">             </span><span class="n">stream</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's change <code>qiskit.eval(20)</code> into <code>qiskit.execute_async(20)</code> to offload the execution of the quantum kernel to the <code>qiskit</code> device. Since this cloud-based environment does not allow non-blocking execution this and <code>qiskit.execute(20)</code> behave identically. If used in a regular program, asynchronous execution immediately returns the scope to the host program and passes a pointer to the <code>QJob</code> object.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">execute_async</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>QJob</code> objects support the following functionality</p>
<h4 id="QObj*-wait()"><code>QObj* wait()</code><a class="anchor-link" href="#QObj*-wait()"> </a></h4><p>waits for the job to complete (blocking)</p>
<h4 id="bool-query()"><code>bool query()</code><a class="anchor-link" href="#bool-query()"> </a></h4><p>returns <code>true</code> if the job completed and <code>false</code> otherwise (non-blocking)</p>
<h4 id="utils::json-get()"><code>utils::json get()</code><a class="anchor-link" href="#utils::json-get()"> </a></h4><p>returns the result as JSON object after completion (blocking)</p>
<p>Let's collect the result of our quantum kernel execution</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Customizing-quantum-kernel-execution">Customizing quantum kernel execution<a class="anchor-link" href="#Customizing-quantum-kernel-execution"> </a></h2><p>The optional hooks <code>script_init</code>, <code>script_before</code>, and <code>script_after</code> and their C++ counterparts <code>ftor_init</code>, <code>ftor_before</code>, and <code>ftor_after</code> make it possible to inject user-defined code at three different locations of the execution process:</p>
<h4 id="script_init"><code>script_init</code><a class="anchor-link" href="#script_init"> </a></h4><p>is performed before any other code of the execution process. It can be used for importing additional Python modules</p>
<h4 id="script_before"><code>script_before</code><a class="anchor-link" href="#script_before"> </a></h4><p>is performed just before sending the instructions to the quantum device. It can be used to pre-process the quantum circuit, e.g., to perform user-specific optimizations on the raw quantum circuit, before it runs through the backend-specific pipeline</p>
<h4 id="script_after"><code>script_after</code><a class="anchor-link" href="#script_after"> </a></h4><p>is performed just after receiving the result from the quantum device. It can be used to post-process the raw results received from the quantum device, e.g., to generate histograms or other types of visualizations</p>
<p>Let's inject a simple statement after the execution that collects the histogram data of the experiment using Qiskit's <a href="https://qiskit.org/documentation/stubs/qiskit.result.Result.html#qiskit.result.Result.get_counts"><code>get_count()</code></a> function</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">execute_async</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* init_script   */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* before_script */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* after_script */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;counts = result.get_counts(qc)</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;return json.dumps(counts)</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                               </span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">job</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">dump</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It should be noted that the code injections are idented automatically and must not have trailing <code>\t</code>'s. Each line must end with <code>\n</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Qiskit comes with a set of <a href="https://qiskit.org/documentation/apidoc/visualization.html">visualizations</a>. Let's inject code that generates a histogram plot and saves it to a file named <code>'histogram.png'</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qiskit</span><span class="p">.</span><span class="n">execute_async</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* init_script   */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;import base64</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;from qiskit.visualization import plot_histogram</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* before_script */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="cm">/* after_script */</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;counts = result.get_counts(qc)</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;plot_histogram(counts, color=&#39;midnightblue&#39;, title=</span><span class="se">\&quot;</span><span class="s">Histogram</span><span class="se">\&quot;</span><span class="s">).savefig(&#39;histogram.png&#39;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                               </span><span class="p">);</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On a regular computer you could simply open the file <code>'histogram.png'</code>. <a href="https://xeus-cling.readthedocs.io/en/latest/rich_display.html">Xeus-cling</a>, which powers this cloud-based tutorial, has the ability to display rich content. All it needs is the following code snippet, which is already included in this environment</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;xtl/xbase64.hpp&quot;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">image</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">png</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kr">inline</span><span class="w"> </span><span class="n">png</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fin</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">m_buffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fin</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">m_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="nf">mime_bundle_repr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">png</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">bundle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bundle</span><span class="p">[</span><span class="s">&quot;image/png&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xtl</span><span class="o">::</span><span class="n">base64encode</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">m_buffer</span><span class="p">.</span><span class="n">str</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bundle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's have a look at our histogram</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-c++"><pre><span></span><span class="n">image</span><span class="o">::</span><span class="n">png</span><span class="w"> </span><span class="nf">histogram</span><span class="p">(</span><span class="s">&quot;histogram.png&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">histogram</span><span class="w"></span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Try yourself some of Qiskit's other visualizations. You can use <code>image::png</code> directly without copying the above code snippet.</p>
<ul>
<li><a href="https://qiskit.org/documentation/stubs/qiskit.visualization.plot_bloch_multivector.html#qiskit.visualization.plot_bloch_multivector">qiskit.visualization.plot_bloch_multivector</a></li>
<li><a href="https://qiskit.org/documentation/stubs/qiskit.visualization.plot_state_city.html#qiskit.visualization.plot_state_city">qiskit.visualization.plot_state_city</a></li>
<li><a href="https://qiskit.org/documentation/stubs/qiskit.visualization.plot_state_hinton.html#qiskit.visualization.plot_state_hinton">qiskit.visualization.plot_state_hinton</a></li>
<li><a href="https://qiskit.org/documentation/stubs/qiskit.visualization.plot_state_paulivec.html#qiskit.visualization.plot_state_paulivec">qiskit.visualization.plot_state_paulivec</a></li>
<li><a href="https://qiskit.org/documentation/stubs/qiskit.visualization.plot_state_qsphere.html#qiskit.visualization.plot_state_qsphere">qiskit.visualization.plot_state_qsphere</a></li>
</ul>

</div>
</div>
</div>
</div>

 


    </main>
    
            </div>
            <div class="c-textbook__footer" id="textbook_footer">
              
<nav class="c-page__nav">
  
    
    

    <a id="js-page__nav__prev" class="c-page__nav__prev" href="/textbook/ch-cse21/cse21-tutorial01.html">
      〈 <span class="u-margin-right-tiny"></span> Part 1
    </a>
  

  
    

    
    <a id="js-page__nav__next" class="c-page__nav__next" href="/textbook/ch-cse21/cse21-tutorial03.html">
      Part 3 <span class="u-margin-right-tiny"></span> 〉
    </a>
  
</nav>

              <footer>
  <p class="footer">This page was created by <a href="https://github.com/jupyter/jupyter-book/graphs/contributors">The Jupyter Book Community</a></p>
</footer>

            </div>

        </div>
      </main>
    </div>
  </body>
</html>
